#!/data/data/com.termux/files/usr/bin/bash
# shellcheck disable=2015,2001,2009,2034,2006

# Debugging
export PS4='$(if [[ $? -eq 0 ]]; then echo -e "\e[0;32m TRUE/DONE\n\n\e[0m"; else echo -e "\e[1;5;31m FALSE/ERROR\n\n\e[0m"; fi) '
# set -x
set -euo pipefail

 ##############################################
 # Author: Kamil BuriXon Burek (BuriXon-code) #
 # Name: Termux-WiFi-map (c) 2025             #
 # Description: Scan and save APs locations   #
 # License: GPLv3.0                           #
 # Version: v 2.0                             #
 # Changelog: major funcionality update       #
 # Todo: change cache'ing method to SQLite    #
 ##############################################

 # Termux-WiFi-map v2.0
 # Copyright (C) 2025  Kamil "BuriXon" Burek (https://burixon.dev)
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.

# Variables
SCRIPT_NAME="Termux-WiFi-map"
SCRIPT_COMMAND="$(basename "$0")"
SCRIPT_AUTHOR="Kamil BuriXon Burek"
SCRIPT_AUTHOR_ALIAS="BuriXon-code"
SCRIPT_VERSION="2.0"
SCRIPT_V_R_DATE="2025"
SCRIPT_PAGE="https://burixon.dev/projects/$SCRIPT_NAME/"
SCRIPT_DONATE="https://burixon.dev/donate/"
SCRIPT_REPORT="https://burixon.dev/bugreport/#$SCRIPT_NAME"

CACHE_DIR="$HOME/.cache/BuriXon-code"
CACHE_FILE="$CACHE_DIR/wifi_scan_cache.jsonl"

PROVIDER="gps"
DELAY=10
ZERO_DELAY=false
DO_VIBRATE=true
EXIT_ON_FAIL=false
CONTINUOUS=false
AP_COUNT=0
H_ENGINE="TERMUX"
H_ENGINE_SET=false

SAVE_OVERRIDE=false
DO_SAVE=false
SAVE_FILE=""
SAVE_FMT=""
SAVE_EXT=""
SAVE_KML_NAME="$SCRIPT_NAME v$SCRIPT_VERSION (c) by $SCRIPT_AUTHOR_ALIAS"

CACHE_LIST=false
CACHE_PURGE=false
CACHE_COUNT=false
JSON_LIST=false
CACHE_SEARCH=false
SEARCH_PATTERN=""

DO_VALID="false"
VALID_FILE=""

GREEN="\e[38;5;120m"
RED="\e[38;5;203m"
YELLOW="\e[38;5;229m"
RESET="\e[0m"

# Messages
error() {
	echo -e "\r\e[1;31m[ERR!]\e[0m $*\e[K" >&2
}
success() {
	echo -e "\r\e[1;32m[DONE]\e[0m $*\e[K"
}
info() {
	echo -e "\r\e[1;33m[INFO]\e[0m $*\e[K"
}
show_help() {
	version_info
	echo -e "
\e[1;36m[Usage]\e[0m $SCRIPT_COMMAND <mode> [options]

\e[1;36m[Modes]\e[0m
  R|-R|--run		Start scanning and saving scanned WiFi networks to cache.
  S|-S|--save		Save collected data to the chosen format (JSON, CSV, KML etc.).
  C|-C|--cache		Manage data in cache (list of known networks).
  V|-V|--check		Check the correctness of the given file structure.
  -v|--version		Display short info about the script version.
  -i|--version-info	Displays detailed info about the script.
  -h|--help		Displays information about options and script usage.\n
\e[1;36m[Options]\e[0m
  \e[36m[RUN]\e[0m
  -p|--provider [option]	Set GPS provider [gps|network|passive] (default: gps)
  -d|--delay [value]		Set delay between scans in seconds [int. 1-3600|none] (default: 10)
  -c|--countinuous		Set working mode to continuous (default: false)
  -q|--quiet			Disable vibration/outputs during scanning (default: false)
  -v|--haptic-engine [option]	Set up the haptic engine [bell|termux] (default: termux-vibrate)
  -e|--exit-on-fail		Exit on Termux:API error (default: false)\n
  \e[36m[SAVE]\e[0m
  -n|--name [filename]		Declare filename to save
  -f|--format [option]		Declare chosen output format [json|pjson|jsonl|csv|kml]
  -o|--override			Allow overwriting an existing file
  -k|--kml-name	[name]		Allow to set the name of the kml document\n
  \e[36m[CACHE]\e[0m
  -l|--list			List all known APs (pretty but slow)
  -j|--json			List all known APs as JSON (fast)
  -c|--count			Display the number of all known APs
  -s|--search [pattern]		Search the given (comma-separated) phrases in the AP data
  -p|--purge			Clear the list of all known APs\n
  \e[36m[CHECK]\e[0m
  /path/to/file			Path to the file to check\n
\e[1;36m[Examples]\e[0m
  Scan once:
  $SCRIPT_COMMAND -R\n
  Continous scanning with 5s delay:
  $SCRIPT_COMMAND --run -d 5 -c\n
  Save DB to file.kml file:
  $SCRIPT_COMMAND -S -n file -f kml\n
  Override existing file.json file:
  $SCRIPT_COMMAND S -n file -f json -o\n
  List all cached APs:
  $SCRIPT_COMMAND -C -l\n
  Search for phrases 'WiFi' and 'AP':
  $SCRIPT_COMMAND -C -s \"WiFi,AP\"\n
  Check file.json integrity:
  $SCRIPT_COMMAND V file.json\n
  Show informations about script:
  $SCRIPT_COMMAND --version-info\n
\e[1;36m[Formats]\e[0m
  JSON		Classic single-line JSON
  PJSON		Pretty formatted JSON
  JSONL		Newline-delimited JSON
  CSV		Comma-separated values
  KML		Format for representing points on maps
"
}
version_info() {
	info "$SCRIPT_NAME v$SCRIPT_VERSION (c) $SCRIPT_V_R_DATE $SCRIPT_AUTHOR"
}

about_info() {
	version_info
	echo -e "
\e[1;36m[About]\e[0m The script \e[1m$(basename "$0")\e[0m, which is the main executable component of the Termux-WiFi-map project, is a tool that allows you to build a database of WiFi networks in your surroundings directly in Termux.\n
\e[1;36m[Options]\e[0m Among the available options, you can find:
	+ scanning with various options
	+ saving collected data to JSON, CSV, KML files
	+ validating files created by the script\n
\e[1;36m[Changelog]\e[0m:
[1.0] - Initial Release
	This is the very first official release of Termux-WiFi-map. 
	It marks the initial version of the tool, providing basic WiFi scanning, data saving, and validation features.
	Future updates will expand functionality and improve usability.
[2.0] - Major functionality update
	This is the second release of the script which, due to the number of introduced changes, received a separate major release.
	This version introduces many improvements, fixes errors and imperfections detected in the previous version and adds a range of new options and functionalities.
	The most important implementations in this version include:
	+ Fixing errors during data parsing by jq - in some Termux and termux-api installations the termux-api command incorrectly intercepted standard streams which caused corrupted JSON to be sent to jq;
	+ Ability to choose a haptic engine - the user can select the vibration engine (termux-api or system bell) through appropriate CLI parameters;
	+ Ability to list saved Access Points in raw JSON form - the previous formatted output generated for a very long time for large AP databases;
	+ Ability to search the collected database - the user can search for specific phrases or strings in the database;
	+ Ability to export specific searches - the user can export to one of the available formats those APs that were previously found.\n
\e[1;36m[License]\e[0m The script is released under the GPLv3 license. \n
This license allows you to freely use, modify, and distribute the script, even for commercial purposes, as long as any distributed versions also remain under GPLv3. \n
It does not allow you to take the script and release it under a different proprietary license, nor does it remove the requirement to share the source code of any modified versions.\n
Visit \e[1;4;36mhttps://www.gnu.org/licenses/gpl-3.0.html\e[0m\e[K for more info.\n
\e[1;36m[URL]\e[0m If you appreciate my work, consider making a donation at: \e[1;4;36m$SCRIPT_DONATE\e[0m\e[K\n
\e[1;36m[URL]\e[0m More information about the script's functionality, version changes, usage, and tips can be found at: \e[1;4;36m$SCRIPT_PAGE\e[0m\e[K\n
\e[1;36m[URL]\e[0mTo report an error visit the page: \e[1;4;36m$SCRIPT_REPORT\e[0m\e[K
"
	# Webpage
	info "Open page now? [y/N] "
	read -rn1 answer
	case "$answer" in
		y)
			echo -en "\e[1A\e[K"
			info "Selecting browser..."
			open_page $SCRIPT_PAGE
			success "Done."
			exit 0
			;;
		*)
			info "Selected: $answer"
			info "Aborting."
			exit 0
			;;
	esac
}
by_termux() {
	if command -v termux-open-url &>/dev/null; then
		termux-open-url "$1"
	else
		error "Cannot open link."
		exit 1
	fi
}
open_page() {
	local page="$1"
	local vnc_proc vnc_pid browser

	for b in firefox firefox-esr chromium brave google-chrome midori qutebrowser netsurf; do
		if command -v "$b" >/dev/null 2>&1; then
			browser="$b"
			break
		fi
	done

	if ps -e | grep -iE 'vnc|tigervnc|vncserver' | grep -v grep &>/dev/null; then
		if ls "$HOME/.vnc/"*.pid 2>/dev/null; then
			if [[ -n "$browser" ]]; then
				"$browser" "$page" & disown
			else
				by_termux "$page"
			fi
		else
			by_termux "$page"
		fi
	else
		by_termux "$page"
	fi
}

echo
# Traps
on_exit() {
	code=$?
	echo -en "\e[0m\e[?25h"
	if [ $code -ne 0 ]; then
		info "Return code: $code"
	fi
	echo
}
trap on_exit EXIT
on_abort() {
	code=$?
	if [[ $code -eq 0 ]]; then
		code=$2
	fi
	error "Operation aborted by $1 signal."
	exit "$code"
}
trap "on_abort SIGINT 130" SIGINT
trap "on_abort SIGTERM 143" SIGTERM
trap "on_abort SIGHUP 129" SIGHUP
trap "on_abort SIGHUP 131" SIGQUIT

# Parse args
parse_args() {
	if [ $# -lt 1 ]; then
		error "The required parameter is missing."
		info "Try to use -h|--help for more info."
		exit 1
	fi
	until [ $# -eq 0 ]; do
		case $1 in
			D|-D|--debug)
				set -x
				shift
				;;
			R|-R|--run)
				shift
				info "Starting..."
				if [ $# -gt 7 ]; then
					error "Too many parameters."
					info "Try to use -h|--help for more info."
					exit 1
				fi
				until [ $# -eq 0 ]; do
					case $1 in
						-p|--provider)
							PROVIDER="$2"
							[[ "$PROVIDER" =~ ^(gps|network|passive)$ ]] || { 
								error "Provider must be gps|network|passive"
								exit 1
							}
							shift 2
							;;
						-c|--countinuous)
							CONTINUOUS=true
							shift
							;;
						-d|--delay)
							DELAY="$2"
							if [[ "$DELAY" == "none" ]]; then
									ZERO_DELAY=true
								fi
								if ! $ZERO_DELAY; then
									if ! [[ "$DELAY" =~ ^[0-9]+$ ]] || \
									[ "$DELAY" -lt 1 ] || \
									[ "$DELAY" -gt 3600 ]; then
										error "Delay value must be 1-3600 or \"none\" for 0s delay."
										exit 1
									fi
								fi
							shift 2
							;;
						-q|--quiet)
							if $H_ENGINE_SET; then error "Cannot set haptic engine if running quiet run."; exit 1; fi
							echo -e "\e[2A"; info "Quiet run..."; echo
							DO_VIBRATE=false
							shift
							;;
						-v|--haptic-engine)
							H_ENGINE_SET=true
							if ! $DO_VIBRATE; then error "Cannot set haptic engine if running quiet run."; exit 1; fi
							case $2 in
								bell) H_ENGINE="BELL" ;;
								termux) H_ENGINE="TERMUX" ;;
								*) error "Invalid haptic engine: $2"; exit 1 ;;
							esac
							shift 2
							;;
						-e|--exit-on-fail)
							EXIT_ON_FAIL=true
							shift
							;;
						*)
							error "Invalid parameter: $1"
							info "Try to use -h|--help for more info."
							exit 1
							;;
					esac
				done
				;;
			C|-C|--cache)
				shift
				if [ $# -gt 2 ]; then
					error "Too many parameters."
					info "Try to use -h|--help for more info."
					exit 1
				elif [ $# -lt 1 ]; then
					error "The required parameter is missing."
					info "Try to use -h|--help for more info."
					exit 1
				fi
				until [ $# -eq 0 ]; do
					case $1 in
						-l|--list)
							CACHE_LIST=true
							shift
							;;
						-j|--json)
							CACHE_LIST=true
							JSON_LIST=true
							shift
							;;
						-p|--purge)
							CACHE_PURGE=true
							shift
							;;
						-c|--count)
							CACHE_COUNT=true
							shift
							;;
						-s|--search)
							CACHE_SEARCH=true
							SEARCH_PATTERN="$2"
							shift 2
							;;
						*)
							error "Invalid parameter: $1"
							info "Try to use -h|--help for more info."
							exit 1
							;;
					esac
				done
				;;
			S|-S|--save)
				shift
				if [ $# -gt 7 ]; then
					error "Too many parameters."
					info "Try to use -h|--help for more info."
					exit 1
				elif [ $# -lt 2 ]; then
					error "The required parameter is missing."
					info "Try to use -h|--help for more info."
					exit 1
				fi
				DO_SAVE=true
				until [ $# -eq 0 ]; do
					case $1 in
						-n|--name)
								SAVE_FILE="$2"
								shift 2
							;;
						-f|--format)
								SAVE_FMT="$2"
								shift 2
							;;
						-o|--override)
								SAVE_OVERRIDE=true
								shift
							;;
						-k|--kml-name)
								SAVE_KML_NAME="$2"
								shift 2
							;;
						*)
								error "Invalid parameter: $1"
								info "Try to use -h|--help for more info."
								exit 1
							;;
					esac
				done
				if $DO_SAVE; then
					if [ -z "$SAVE_FILE" ] || [ -z "$SAVE_FMT" ]; then
						error "The required parameters are missing."
						info "Try to use -h|--help for more info."
						exit 1
					fi
				fi
				;;
			V|-V|--check)
				shift
				if [ $# -gt 1 ]; then
					error "Too many parameters."
					info "Try to use -h|--help for more info."
					exit 1
				elif [ $# -lt 1 ]; then
					error "The required parameter is missing."
					info "Try to use -h|--help for more info."
					exit 1
				fi
				until [ $# -eq 0 ]; do
					case $1 in
						-*)
							error "Invalid parameter: $1"
							info "Try to use -h|--help for more info."
							exit 1
							;;
						*)
							VALID_FILE="$1"
							shift
							DO_VALID=true
							;;
					esac
				done
				;;
			-h|--help)
				show_help
				exit 0
				;;
			-v|--version)
				version_info
				exit 0
				;;
			-i|--version-info)
				about_info
				;;
			--report)
				info "Selecting browser..."
				open_page $SCRIPT_REPORT
				success "Done."
				exit 0
				;;
			*)
				error "Invalid parameter: $1"
				info "Try to use -h|--help for more info."
				exit 1
				;;
		esac
	done
}

# Catch stdout pipe'ing
if [ -p /proc/$$/fd/1 ]; then
	echo -e "\n${RED}[WARN]${RESET} $SCRIPT_COMMAND does not have a stable CLI interface. Use with caution in scripts.\n" >&2
else
	echo -en "\e[?25l"
fi

# Init
req() {
	MISSING=false
	for c in termux-wifi-scaninfo jq termux-location termux-api-start termux-api-stop timeout awk sed tr date termux-vibrate; do
		command -v "$c" >/dev/null 2>&1 || { error "Missing: $c"; MISSING=true; }
	done
	if $MISSING; then
		error "Some dependencies are missing."
		exit 1
	fi
}
ensure_cache() {
	mkdir -p "$CACHE_DIR"
	touch "$CACHE_FILE"
}

# Restart API
api_restart() {
	if $EXIT_ON_FAIL; then
		info "The -e|--exit-on-fail option was enabled."
		error "API failed. Aborting."
		exit 1
	else
		ERRORS=0
		info "Restarting API..."
		termux-api-stop >/dev/null 2>&1
		STATUS=$?
		ERRORS=$((ERRORS + STATUS))
		sleep 1
		termux-api-start >/dev/null 2>&1
		STATUS=$?
		ERRORS=$((ERRORS + STATUS))
		sleep 1
		if [ $STATUS -ne 0 ]; then
			error "Restarting failed."
			exit 1
		fi
	fi
}

# Get location
	# TODO : get prev. loc. on error
get_location() {
	local tries=0
	while :; do
		local j
		j=$(timeout 15 termux-location -p "$PROVIDER" 2>/dev/null || true)
		local lat lon alt
		lat=$(printf "%s" "$j" | jq -r 'try .latitude // empty')
		lon=$(printf "%s" "$j" | jq -r 'try .longitude // empty')
		alt=$(printf "%s" "$j" | jq -r 'try .altitude // 0')
		if [ -n "$lat" ] && [ -n "$lon" ]; then
			echo "$lat;$lon;$alt"
			return 0
		fi
		tries=$((tries+1))
		[ $tries -ge 3 ] && {
			if $EXIT_ON_FAIL; then
				error "Fail. Aborting."
				exit 129
			else
				return 1
			fi
		}
		api_restart
	done
}

# Check caps.
is_locked() {
	printf "%s" "$1" | grep -Eq 'WEP|WPA|PSK|SAE'
}

# Print verbose data
print_net() {
	local ssid="$1" bssid="$2" rssi="$3" freq="$4" caps="$5" lat="$6" lon="$7"
	local hidden=""

	if [ -z "$ssid" ] || [ "$ssid" = "null" ]; then
		hidden="${YELLOW}[HIDDEN]${RESET} "
		ssid="(hidden)"
	fi

	if is_locked "$caps"; then
		printf "%b%b[LOCK]%b %s | %s | RSSI:%s | %sMHz | %s | %.8f,%.8f\n" \
			"$hidden" "$RED" "$RESET" "$ssid" "$bssid" "$rssi" "$freq" "$caps" "$lat" "$lon"
	else
		printf "%b%b[OPEN]%b %s | %s | RSSI:%s | %sMHz | %s | %.8f,%.8f\n" \
			"$hidden" "$GREEN" "$RESET" "$ssid" "$bssid" "$rssi" "$freq" "$caps" "$lat" "$lon"
	fi
}

#JUST CURRENT TIME :)
now_utc() {
	date -u +"%Y-%m-%dT%H:%M:%SZ"
}

# Scan
scan_once() {
	local loc
	loc=$(get_location) || { error "Location error (provider=$PROVIDER)."; api_restart; loc=$(get_location) || return 1; }

	local lat lon alt
	IFS=';' read -r lat lon alt <<<"$loc"

	local raw
	raw=$(termux-wifi-scaninfo 2>/dev/null || true)
	if [ -z "$raw" ]; then
		error "Wi-Fi scan failed."
		api_restart
		raw=$(termux-wifi-scaninfo 2>/dev/null || true)
	fi
	[ -z "$raw" ] && return 1

	while IFS= read -r -u 3 line; do
		local ssid bssid rssi freq caps
		ssid=$(printf "%s" "$line" | jq -r '.ssid')
		bssid=$(printf "%s" "$line" | jq -r '.bssid')
		rssi=$(printf "%s" "$line" | jq -r '.rssi')
		freq=$(printf "%s" "$line" | jq -r '.frequency_mhz')
		caps=$(printf "%s" "$line" | jq -r '.capabilities')

		if ! jq -e --arg ssid "$ssid" --arg bssid "$bssid" \
			'select(.ssid==$ssid and .bssid==$bssid)' "$CACHE_FILE" >/dev/null; then
			if $DO_VIBRATE; then
				case $H_ENGINE in
					BELL) echo -en "\a" ;;
					TERMUX) termux-vibrate -d 50 </dev/null >/dev/null ;;
				esac
				print_net "$ssid" "$bssid" "$rssi" "$freq" "$caps" "$lat" "$lon"
			else
				((AP_COUNT++))
				echo -en "\e[1A"; info "Found $AP_COUNT..."
			fi
			printf "%s\n" "$line" | jq -c --arg t "$(now_utc)" --arg p "$PROVIDER" --argjson la "$lat" --argjson lo "$lon" --argjson al "${alt:-0}" \
				'. + {time:$t,provider:$p,latitude:$la,longitude:$lo,altitude:$al}' >> "$CACHE_FILE"
		fi
	done 3< <(printf "%s" "$raw" | jq -c '.[] | {ssid:.ssid,bssid:.bssid,rssi:.rssi,frequency_mhz:.frequency_mhz,capabilities:.capabilities}')
}

# List
list_cache() {
	[ -s "$CACHE_FILE" ] || { error "Cache empty: try to scan first."; exit 0; }

	local TOTAL SSID
	TOTAL=$(wc -l < "$CACHE_FILE")
	info "Entries count: $TOTAL"
	echo

	if $JSON_LIST; then
		cat "$CACHE_FILE" | jq
	else
		while IFS= read -r entry; do
			SSID=$(jq -r 'if .ssid == null or .ssid == "" then "hidden" else .ssid end' <<<"$entry")
			[[ $SSID == "hidden" ]] && SSID="\e[2m(hidden)\e[0m"
			echo -e "\e[36mSSID\e[33m:\e[0m         $SSID"
			echo -e "\e[36mBSSID\e[33m:\e[0m        $(jq -r '.bssid' <<<"$entry")"
			echo -e "\e[36mRSSI\e[33m:\e[0m         $(jq -r '.rssi // ""' <<<"$entry")"
			echo -e "\e[36mFrequency\e[33m:\e[0m    $(jq -r '.frequency_mhz // ""' <<<"$entry")"
			echo -e "\e[36mCapabilities\e[33m:\e[0m $(jq -r '.capabilities // ""' <<<"$entry")"
			echo -e "\e[36mProvider\e[33m:\e[0m     $(jq -r '.provider' <<<"$entry")"
			echo -e "\e[36mLatitude\e[33m:\e[0m     $(jq -r '.latitude // ""' <<<"$entry")"
			echo -e "\e[36mLongitude\e[33m:\e[0m    $(jq -r '.longitude // ""' <<<"$entry")"
			echo -e "\e[36mAltitude\e[33m:\e[0m     $(jq -r '.altitude // ""' <<<"$entry")"
			echo
		done < "$CACHE_FILE"
	fi

	success "Done - $TOTAL"
}

# Count
count_cache() {
	local TOTAL
	TOTAL=$(wc -l < "$CACHE_FILE")
	info "Entries count: $TOTAL"
	success "Done"
}

# Purge
purge_cache() {
	info "Are you sure you want to purge the script's cache? [y/N]"
	echo -en "\e[1A"
	read -rn1 answer
	echo -ne "\r\e[K"
	if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
		rm -f "$CACHE_FILE"
		ensure_cache
		success "Cache purged."
		exit 0
	elif [[ "$answer" == "n" || "$answer" == "N" ]]; then
		info "Operation aborted."
		exit 0
	else
		error "Invalid option $answer!"
		info "Operation aborted."
		exit 1
	fi
}

# Search
search_cache() {
	colors=(200 196 208 226 155 159 123 118 111 10)	
	for i in "${!colors[@]}"; do
		j=$((RANDOM % (${#colors[@]} - i) + i))
		tmp=${colors[i]}
		colors[i]=${colors[j]}
		colors[j]=$tmp
	done
	MATCHING_COUNT=0
	if [ ! -f "$CACHE_FILE" ]; then
		error "Cache file not found. Try to scan first."
		exit 1
	fi
	if [ -z "$SEARCH_PATTERN" ] || ! [[ "$SEARCH_PATTERN" =~ [^[:space:]] ]]; then
		error "Search pattern is empty."
		exit 1
	fi
	IFS=',' read -ra arr <<< "$SEARCH_PATTERN"
		if [ "${#arr[@]}" -gt 10 ]; then
		error "Too many patterns: ${#arr[@]}. Maximum allowed is 10."
		exit 1
	fi
	regex=`printf "%s|" "${arr[@]}"`
	regex=${regex%|}
	index=0
	pattern_line=""
	for pattern in "${arr[@]}"; do
		color=${colors[$index]}
		index=$((index+1))
		pattern_line+=$(printf "\033[38;5;%sm\033[1m%s\033[0m " "$color" "$pattern")
	done
	info "Search patterns: $pattern_line"
	if ! grep -E "$regex" "$CACHE_FILE" >/dev/null 2>&1; then
		error "No matches found."
		exit 1
	fi
	MATCHING_COUNT=`grep -E -c "$regex" "$CACHE_FILE"`
	grep -E "$regex" "$CACHE_FILE" |
	while IFS= read -r line; do
		echo; info "Found:"
		if ! json=`printf "%s" "$line" | jq . 2>/dev/null`; then
			error "Failed to parse JSON."
			exit 1
		fi
		index=0
		out="$json"
		for pattern in "${arr[@]}"; do
			color=${colors[$index]}
			index=$((index+1))
			if ! out=`printf "%s" "$out" | sed "s/${pattern}/$(printf '\033[38;5;%sm\033[1m%s\033[0m' "$color" "$pattern")/g"`; then
				error "Failed during formatting."
				exit 1
			fi
		done
		printf "%s\n" "$out"
		MATCHING_COUNT=$((MATCHING_COUNT+1))
	done
	echo; info "Search patterns: $pattern_line"
	info "Matching: $MATCHING_COUNT"
	info "Export founded data? [y/N] "
	read -rn1 do_export
	case "$do_export" in
		y)
			FILTERED_CACHE=$(mktemp)
			grep -E "$regex" "$CACHE_FILE" > "$FILTERED_CACHE"
			echo -en "\e[?25h`info "Select output format (json|jsonl|pjson|csv|kml): "`"
			read -r FILTERED_FMT
			echo -en "\e[?25l"
			do_save "$FILTERED_CACHE" "$FILTERED_FMT"
			;;
		*)
			info "Selected: $do_export"
			info "Aborting."
			;;
	esac
	success "Done."
	exit 0
}

# Check file
check_file_exists() {
	if ! $SAVE_OVERRIDE; then
		if [ -f "${SAVE_FILE}.${SAVE_EXT}" ]; then
				error "File ${SAVE_FILE}.${SAVE_EXT} already exists."
				info "Select another filename or try to use -o option."
				exit 1
		else
			return 0
		fi
	else
		return 0
	fi
}

# Save json
save_json_min() {
	jq -cs '.' "$CACHE_FILE" | tr -d '\n' > "${SAVE_FILE}.${SAVE_EXT}" || { error "Error while saving file."; exit 1; }
	success "File saved: ${SAVE_FILE}.${SAVE_EXT}"
}

# Save pretty json
save_json_pretty() {
	jq -cs '.' "$CACHE_FILE" | jq '.' > "${SAVE_FILE}.${SAVE_EXT}" || { error "Error while saving file."; exit 1; }
	success "File saved: ${SAVE_FILE}.${SAVE_EXT}"
}

# Save jsonl
save_json_list() {
	{ [ -f "$CACHE_FILE" ] && [[ $( wc -l < "$CACHE_FILE" ) -gt 0 ]]; } && {
		cp "$CACHE_FILE" "${SAVE_FILE}.${SAVE_EXT}" || { error "Error while saving file."; exit 1; }
		success "File saved: ${SAVE_FILE}.${SAVE_EXT}"
	} || { error "Cache empty: try to scan first."; exit 1; }
}

# Save csv 
save_csv() {
	{
		echo "time,ssid,bssid,rssi,frequency_mhz,capabilities,provider,latitude,longitude,altitude"
		jq -r '. | [.time, (.ssid//"(hidden)"), .bssid, (.rssi//""), (.frequency_mhz//""), (.capabilities//""), .provider, (.latitude|tostring), (.longitude|tostring), (.altitude|tostring)] | @csv' "$CACHE_FILE"
	} > "${SAVE_FILE}.${SAVE_EXT}" || { error "Error while saving file."; exit 1; }
	success "File saved: ${SAVE_FILE}.${SAVE_EXT}"
}

# Jitter for KML
jitter_pair() {
	local bssid="$1"
	local seed
	seed=$(printf "%s" "$bssid" | cksum | awk '{print $1}')
	local a=$(( (seed % 1001) - 500 ))
	local b=$(( ((seed/7) % 1001) - 500 ))
	local dlat dlng
	dlat=$(awk -v n="$a" 'BEGIN{printf "%.7f", n/10000000}')
	dlng=$(awk -v n="$b" 'BEGIN{printf "%.7f", n/10000000}')
	printf "%s;%s" "$dlat" "$dlng"
}

# Save kml
save_kml() {
	local tmp="$SAVE_FILE.tmp"
	: > "$tmp"	
	{
		echo '<?xml version="1.0" encoding="UTF-8"?>'
		echo '<kml xmlns="http://www.opengis.net/kml/2.2"><Document>'
		echo "  <name>$SAVE_KML_NAME</name>"
		echo '  <Style id="open"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/paddle/grn-blank.png</href></Icon></IconStyle></Style>'
		echo '  <Style id="lock"><IconStyle><Icon><href>http://maps.google.com/mapfiles/kml/paddle/red-blank.png</href></Icon></IconStyle></Style>'
	} >> "$tmp"
	CURRENT=0
	TOTAL=$(wc -l < "$CACHE_FILE")
	PERCENT=$(( CURRENT*100/TOTAL ))
	info "Progress data conversion... ${PERCENT}%"
	echo -e "${YELLOW}[SSID]${RESET} Starting..."
	jq -c '.' "$CACHE_FILE" 2>/dev/null | while IFS= read -r row; do
		CURRENT=$(( CURRENT+1 ))
		PERCENT=$(( CURRENT*100/TOTAL ))
		echo -en "\e[2A"
		info "Progress data conversion... ${PERCENT}%\e[K"
		local ssid bssid caps time lat lon alt
		ssid=$(printf "%s" "$row" | jq -r '(.ssid//"(hidden)")')
		bssid=$(printf "%s" "$row" | jq -r '.bssid')
		caps=$(printf "%s" "$row" | jq -r '(.capabilities//"")')
		time=$(printf "%s" "$row" | jq -r '.time')
		lat=$(printf "%s" "$row" | jq -r '.latitude')
		lon=$(printf "%s" "$row" | jq -r '.longitude')
		alt=$(printf "%s" "$row" | jq -r '(.altitude//0)')
		echo -e "${YELLOW}[SSID]${RESET} ${ssid:-(hidden)}\e[K"
		[ -z "$lat" ] || [ -z "$lon" ] && continue
		local jl jg
		IFS=';' read -r jl jg <<<"$(jitter_pair "$bssid")"
		local jlat jlon
		jlat=$(awk -v a="$lat" -v b="$jl" 'BEGIN{printf "%.8f", a+b}')
		jlon=$(awk -v a="$lon" -v b="$jg" 'BEGIN{printf "%.8f", a+b}')
		local style
		if is_locked "$caps"; then style="#lock"; else style="#open"; fi
		{
			echo "  <Placemark>"
			echo "    <name><![CDATA[$ssid]]></name>"
			echo "    <description><![CDATA[$bssid | $caps | $time]]></description>"
			echo "    <styleUrl>$style</styleUrl>"
			echo "    <Point><coordinates>$jlon,$jlat,$alt</coordinates></Point>"
			echo "  </Placemark>"
		} >> "$tmp" || { error "Scan error."; exit 1; }
	done
	echo '</Document></kml>' >> "$tmp"
	mv "$tmp" "${SAVE_FILE}.${SAVE_EXT}" || { error "Some error occured while saving file."; exit 1; }
	echo -en "\e[1A"
	echo -e "${YELLOW}[SSID]${RESET}\e[0m ---\e[K"
	success "File saved: ${SAVE_FILE}.${SAVE_EXT}"
}

# Save method
do_save() {
	if [ $# -eq 2 ]; then
		CACHE_FILE="$1"
		SAVE_FMT="$2"
		SAVE_FILE="$SEARCH_PATTERN"
		SAVE_OVERRIDE=true
	fi
	[ -s "$CACHE_FILE" ] || { error "Cache empty: try to scan first."; exit 1; }
	case "$SAVE_FMT" in
		json)
			SAVE_EXT="json"
			check_file_exists
			save_json_min
			;;
		pjson)
			SAVE_EXT="json"
			check_file_exists
			save_json_pretty
			;;
		jsonl)
			SAVE_EXT="jsonl"
			check_file_exists
			save_json_list
			;;
		csv)
			SAVE_EXT="csv"
			check_file_exists
			save_csv
			;;
		kml)
			SAVE_EXT="kml"
			check_file_exists
			save_kml
			;;
		*)
			error "Unknown format: $SAVE_FMT"
			exit 1
			;;
	esac
}

# Check
valid() {
	local FILE SSID MIME TYPE LINES
	FILE="$VALID_FILE"
	[ ! -f "$FILE" ] && error "No file: $FILE" && exit 1
	
	info "Checking: $FILE"
	
	MIME=$(file --mime-type -b "$FILE")
	TYPE="unknown"
	LINES=$(wc -l < "$FILE")
	
	case "$MIME" in
	    application/xml|text/xml)
	        if grep -q "<kml" "$FILE"; then
	            TYPE="KML"
	        fi
	        ;;
	    application/json)
	        if [ "$LINES" -gt 1 ]; then
	            TYPE="Pretty JSON"
	        else
	            TYPE="JSON"
	        fi
	        ;;
	    application/x-ndjson)
	        TYPE="JSONL"
	        ;;
	    text/csv)
	        if grep -q ',' "$FILE"; then
	            TYPE="CSV"
	        fi
	        ;;
	esac
	
	info "Detected type: $TYPE"
	
	case "$TYPE" in
	    KML)
	  	    info "Validating KML..."
	        if ! xmllint --noout "$FILE" 2>/dev/null; then
	            error "File is not well-formed XML"
	        else
	            success "Well-formed XML"
	        fi
	
	        NAME=$(grep -oPm1 "(?<=<name>).*?(?=</name>)" "$FILE" || echo "unknown")
	        info "Name: $NAME"
	
	        POINTS=$(grep -o "<Point>" "$FILE" | wc -l)
	        info "Points: $POINTS"
	
	        ICONS=$(grep -oPm999 "(?<=<href>).*?(?=</href>)" "$FILE" || true)
	        if [ -n "$ICONS" ]; then
	            info "Found href/icons:"
	            while IFS= read -r icon; do
	                echo "   - $icon"
	                if [[ "$icon" =~ ^https?:// ]]; then
	                    STATUS=$(curl -Is -o /dev/null -w "%{http_code}" --max-time 5 "$icon" || echo "000")
	                    if [[ "$STATUS" == 200 ]]; then
	                        success "      Link works (HTTP $STATUS)"
	                    else
	                        error "      Link problem (HTTP $STATUS)"
	                    fi
	                elif [ -f "$icon" ]; then
	                    success "      Local file exists"
	                else
	                    error "      Local file not found"
	                fi
	            done <<< "$ICONS"
	        else
	            success "No custom icons"
	        fi
	
	        TAGS=$(grep -o "<[^!?/][^ >/]*" "$FILE" | sed 's/[<]//' | sort -u)
	        info "Tags in file:"
	        echo "$TAGS" | sed 's/^/   - /'
	
	        info "Checking tag balance..."
	        OPEN_TAGS=$(grep -o "<[^!?/][^ >/]*" "$FILE" | sed 's/[<]//' | sort | uniq -c)
	        CLOSE_TAGS=$(grep -o "</[^>]*>" "$FILE" | sed 's/[<\/>]//g' | sort | uniq -c)
	
	        MISMATCH=0
	        for t in $(echo "$OPEN_TAGS" | awk '{print $2}'); do
	            open_count=$(echo "$OPEN_TAGS" | awk -v tag="$t" '$2==tag {print $1}')
	            close_count=$(echo "$CLOSE_TAGS" | awk -v tag="$t" '$2==tag {print $1}')
	            [ -z "$close_count" ] && close_count=0
	            if [ "$open_count" -ne "$close_count" ]; then
	                error "Tag <$t>: opened $open_count, closed $close_count"
	                MISMATCH=1
	            fi
	        done
	        [ $MISMATCH -eq 0 ] && success "Valid KML file."
	        ;;
	    CSV)
	   		info "Validating CSV..."
	        COLS=$(head -n1 "$FILE" | awk -v FPAT='([^,]+)|(\"[^\"]+\")' 'END{print NF}')
	        BAD_LINES=""
	        LINE_NO=0
	        echo
	        while IFS= read -r line; do
	            SSID=$(echo -n "$line" | cut -d "," -f 2 | cut -d '"' -f 2)
	            echo -e "\e[1A$SSID\e[K"
	            LINE_NO=$((LINE_NO+1))
	            COUNT=$(echo "$line" | awk -v FPAT='([^,]+)|(\"[^\"]+\")' 'END{print NF}')
	            if [ "$COUNT" -ne "$COLS" ]; then
	                BAD_LINES+="$LINE_NO "
	            fi
	        done < "$FILE"
	
	        if [ -n "$BAD_LINES" ]; then
	            echo -en "\e[1A\e[K"
	            error "Some lines have wrong number of columns:"
	            echo "$BAD_LINES" | sed 's/^/   Line /'
	        else
	            echo -en "\e[1A\e[K"
	            success "Valid CSV file."
	        fi
	        ;;
	    JSON)
	        info "Validating JSON..."
	        if ! jq empty "$FILE" >/dev/null 2>&1; then
	            error "JSON invalid"
	        else
	            COUNT=$(jq 'if type=="array" then length else 1 end' "$FILE")
	            KEYS=$(jq -r 'if type=="array" then .[0] | keys[] else keys[] end' "$FILE" 2>/dev/null | sort -u)
	            info "Top-level element count: $COUNT"
	            info "Keys found:"
	            echo "$KEYS" | sed 's/^/   - /'
	            success "Valid JSON file."
	        fi
	        ;;
	    Pretty\ JSON)
	        info "Validating Pretty JSON..."
	        if ! jq empty "$FILE" >/dev/null 2>&1; then
	            error "Pretty JSON invalid"
	        else
	            COUNT=$(jq 'if type=="array" then length else 1 end' "$FILE")
	            KEYS=$(jq -r 'if type=="array" then .[0] | keys[] else keys[] end' "$FILE" 2>/dev/null | sort -u)
	            info "Top-level element count: $COUNT"
	            info "Keys found:"
	            echo "$KEYS" | sed 's/^/   - /'
	            success "Valid Pretty JSON file."
	        fi
	        ;;
	    JSONL)
	        info "Validating JSONL..."
	        LINE_NO=0
	        BAD_LINES=""
	        echo
	        while IFS= read -r line; do
	            SSID=$(echo -n "$line" | jq -r .ssid)
	            echo -e "\e[1A$SSID\e[K"
	            LINE_NO=$((LINE_NO+1))
	            if ! echo "$line" | jq empty >/dev/null 2>&1; then
	                BAD_LINES+="$LINE_NO "
	            fi
	        done < "$FILE"
	        if [ -n "$BAD_LINES" ]; then
	            echo -en "\e[1A\e[K"
	            error "Invalid JSON on lines:$BAD_LINES"
	        else
	            echo -en "\e[1A\e[K"
	            success "Valid JSONL file."
	        fi
	        ;;
	    *)
	        error "Could not determine exact file type, guessing..."
	        SAMPLE=$(head -n200 "$FILE")
	        MIGHT_TYPE="unknown"
	
	        CSV_LINES=$(echo "$SAMPLE" | awk -F',' 'BEGIN{count=0} NF>3{count++} END{print count}')
	        if [ "$CSV_LINES" -ge 10 ]; then
	            ONE_LINE=$(shuf -n1 "$FILE")
	            CSV_LINE=$(echo "$ONE_LINE" | awk -F',' 'BEGIN{count=0} NF>3{count++} END{print count}')
	            if [ "$CSV_LINE" -ge 3 ]; then
	                MIGHT_TYPE="CSV"
	            fi
	        fi
	
	        if [ "$MIGHT_TYPE" = "unknown" ]; then
	            LINES=$(echo "$SAMPLE" | wc -l)
	
	            JSONL_COUNT=0
	            while IFS= read -r line; do
	                if [[ "$line" =~ ^[[:space:]]*\{.*\}[[:space:]]*$ ]]; then
	                    if echo "$line" | jq empty >/dev/null 2>&1; then
	                        JSONL_COUNT=$((JSONL_COUNT+1))
	                    fi
	                fi
	            done <<< "$SAMPLE"
	
	            if [ "$JSONL_COUNT" -ge 2 ]; then
	                MIGHT_TYPE="JSONL"
	            else
	                FRAG=$(grep -o '{.*}' "$FILE" | shuf -n1)
	                if [ -n "$FRAG" ] && echo "$FRAG" | jq empty >/dev/null 2>&1; then
	                    MIGHT_TYPE="Pretty JSON"
	                else
	                    if jq empty "$FILE" >/dev/null 2>&1; then
	                        MIGHT_TYPE="JSON"
	                    fi
	                fi
	            fi
	        fi
	
	        if [ "$MIGHT_TYPE" = "unknown" ] && echo "$SAMPLE" | grep -q '<xml'; then
	            if [ "$MIGHT_TYPE" = "unknown" ] && echo "$SAMPLE" | grep -q '<kml'; then
	                MIGHT_TYPE="KML"
	            fi
	        fi
	
	        if [[ "$MIGHT_TYPE" != "unknown" ]]; then
	            info "Might be: $MIGHT_TYPE"
	        else
	            error "Unable to determine file type."
	        fi
	        ;;
	esac
}

# RUN :)
main() {
	req
	ensure_cache
	parse_args "$@"
	if $DO_SAVE; then do_save; exit 0; fi
	if $CACHE_LIST; then list_cache; exit 0; fi
	if $DO_VALID; then valid; exit 0; fi
	if $CACHE_COUNT; then count_cache; exit 0; fi
	if $CACHE_PURGE; then purge_cache; fi
	if $CACHE_SEARCH; then search_cache; fi
	while :; do
		scan_once || error "Scan error."
		$CONTINUOUS || break
		if ! $ZERO_DELAY; then
			sleep "$DELAY"
		fi
	done
}

main "$@"
